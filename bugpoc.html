<!DOCTYPE html>
<html>
<head>
  <title>V8 Bad-Free Continuous Fuzzer</title>
</head>
<body>
<script>
// Continuous high-pressure JIT churn fuzzer
// Targets: ThreadIsolation::UnregisterJitPage (code-memory-access.cc)

function makeJitFunction(seed) {
  // Unique, non-inlineable, non-optimizable-yet-JIT-able body
  return new Function(`
    let a = ${seed};
    for (let i = 0; i < 3000; i++) {
      a = (a * 1664525 + 1013904223) | 0;
    }
    return a;
  `);
}

function fuzzRound() {
  const N = 6000;
  const funcs = new Array(N);

  // 1. Allocate & JIT many unique functions
  for (let i = 0; i < N; i++) {
    const f = makeJitFunction((Math.random() * 1e9) | 0);
    f(); // Trigger compilation
    funcs[i] = f;
  }

  // 2. Null all to make collectible
  for (let i = 0; i < N; i++) {
    funcs[i] = null;
  }

  // 3. Force aggressive sweeping
  if (typeof gc === 'function') {
    for (let i = 0; i < 20; i++) gc();
  }

  // 4. Allocate another batch immediately
  const funcs2 = new Array(N);
  for (let i = 0; i < N; i++) {
    const f = makeJitFunction((Math.random() * 1e9) | 0 + 0x1337);
    f();
    funcs2[i] = f;
  }
  funcs2.length = 0;

  if (typeof gc === 'function') {
    for (let i = 0; i < 15; i++) gc();
  }
}

// Run rounds as fast as possible â€” no delays, no navigation
let round = 0;
while (true) {
  // Optional: log every 10 rounds (may slow down slightly)
  // if (++round % 10 === 0) console.log("Fuzz round", round);

  fuzzRound();
}
</script>
</body>
</html>
