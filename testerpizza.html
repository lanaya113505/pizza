<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TypedArray Stress Test – Auto Run</title>
<style>
  body { font-family: monospace; background:#111; color:#0f0; padding:20px; }
  #log { white-space:pre; background:#000; padding:10px; height:400px; overflow-y:scroll; border:1px solid #0f0; }
</style>
</head>
<body>

<h2>TypedArray Stress Test (Auto-Run)</h2>
<pre id="log"></pre>

<script>
'use strict';
(function(){

  const logEl = document.querySelector('#log');
  let stopFlag = false;

  function log(...args){
    const t = args.join(' ');
    logEl.textContent += t + "\n";
    logEl.scrollTop = logEl.scrollHeight;
    console.log("[stress]", ...args);
  }

  // === Tambahan: laporan error + stack trace global ===
  window.onerror = function(msg, url, line, col, err){
    log("GLOBAL ERROR:", msg);
    if (err && err.stack) log("STACK:\n" + err.stack);
  };
  window.onunhandledrejection = function(ev){
    log("UNHANDLED REJECTION:", ev.reason);
    if (ev.reason && ev.reason.stack) log("STACK:\n" + ev.reason.stack);
  };

  // ============================================================
  //      STRESS TEST ENGINE (tak diubah dari fungsional asli)
  // ============================================================

  function stressTypedArrayTask(TCtorName, bytes, iterations, pattern, op){
    const TCtor = self[TCtorName];
    if (!TCtor) throw new Error('Unknown type: ' + TCtorName);
    const BPE = TCtor.BYTES_PER_ELEMENT || 1;
    const len = Math.max(1, (bytes / BPE) | 0);

    const rem16 = len % 16;

    function fill(arr){
      let i = 0;
      switch(pattern){
        case 'xor':
          for (; i < len - rem16; i += 16){
            for (let k=0;k<16;k++){
              const t = i+k;
              arr[t] = (t ^ (t<<3)) & 0xff;
            }
          }
          for (; i < len; i++) arr[i] = (i ^ (i<<3)) & 0xff;
          break;

        case 'lcg': {
          let seed = 0x9e3779b9 ^ len;
          const a = 1664525>>>0, c = 1013904223>>>0;
          for (; i < len; i++){
            seed = (a*seed + c)>>>0;
            arr[i] = seed & 0xff;
          }
          break;
        }

        case 'linear':
        default:
          for (; i < len; i++) arr[i] = i & 0xff;
      }
    }

    let checksum = 0n;

    function reduce(arr){
      let s = 0n;
      for (let i=0;i<arr.length;i++){
        const v = BigInt(arr[i]);
        s += (op === 'mix') ? ((v * 13n) ^ (v << 5n)) : v;
      }
      return s;
    }

    const t0 = performance.now();
    for (let it = 0; it < iterations; it++){
      if (stopFlag) break;
      const arr = new TCtor(len);
      fill(arr);
      checksum ^= reduce(arr);
    }
    const t1 = performance.now();

    return {
      type: TCtorName,
      len,
      bytes,
      iterationsRan: iterations,
      ms: (t1 - t0),
      checksum: checksum.toString()
    };
  }

  function workerBlob(){
    const src = `(${stressTypedArrayTask.toString()}); onmessage = e => {
      const { type, bytes, iterations, pattern, op } = e.data;
      try {
        const r = stressTypedArrayTask(type, bytes, iterations, pattern, op);
        postMessage({ ok:true, r });
      } catch(err){
        postMessage({ ok:false, err:String(err), stack:err.stack });
      }
    };`;
    return URL.createObjectURL(new Blob([src], { type: "application/javascript" }));
  }

  // ============================================================
  //                     AUTO RUN SUITE
  // ============================================================

  async function runSuite(){
    stopFlag = false;

    // Setting otomatis (tanpa input user)
    const sizeMB      = 64;       // 64MB per test
    const iterations  = 6;
    const pattern     = "xor";
    const op          = "mix";
    const types       = [
      "Uint8Array","Uint16Array","Uint32Array",
      "Int8Array","Int16Array","Int32Array",
      "Float32Array","Float64Array"
    ];

    const useWorkers  = true;
    const workerCount = Math.max(1, navigator.hardwareConcurrency || 4);

    const bytes = sizeMB * 1024 * 1024;
    const totalStart = performance.now();
    log("--- AUTO RUN START ---");
    log("config:", JSON.stringify({ sizeMB, iterations, workerCount, pattern, op }));

    if (useWorkers){
      const url = workerBlob();
      const jobs = [];

      for (const type of types){
        const perWorker = Math.max(1, Math.floor(iterations / workerCount));
        const remainder = iterations - perWorker * workerCount;
        for (let w=0; w<workerCount; w++){
          const it = w < remainder ? perWorker + 1 : perWorker;
          jobs.push({ type, it });
        }
      }

      const results = await Promise.all(
        jobs.map(job => new Promise(res => {
          const wr = new Worker(url);
          wr.onmessage = ev => { wr.terminate(); res(ev.data); };
          wr.onerror   = ev => { wr.terminate(); res({ ok:false, err:String(ev.message||ev), stack:ev.error?.stack }); };
          wr.postMessage({
            type: job.type,
            bytes,
            iterations: job.it,
            pattern,
            op
          });
        }))
      );

      URL.revokeObjectURL(url);

      let agg = 0n;
      let ok=0, fail=0;

      for (const r of results){
        if (r.ok){
          ok++;
          agg ^= BigInt(r.r.checksum);
          log(`✓ type=${r.r.type} it=${r.r.iterationsRan} time=${r.r.ms.toFixed(1)}ms checksum=${r.r.checksum}`);
        } else {
          fail++;
          log("✗ worker error:", r.err);
          if (r.stack) log("STACK:\n" + r.stack);
        }
      }

      const totalEnd = performance.now();
      log(`Workers done. ok=${ok} fail=${fail} wall=${(totalEnd-totalStart).toFixed(1)}ms agg=${agg}`);
    }

    log("--- AUTO RUN END ---");
  }

  // ============================================================
  //               LANGSUNG OTOMATIS BERJALAN DI SINI
  // ============================================================

  window.onload = () => {
    log("Auto-run triggered...\n");
    runSuite().catch(err=>{
      log("AUTO ERR:", err);
      if (err.stack) log("STACK:\n" + err.stack);
    });
  };

})();
</script>

</body>
</html>
